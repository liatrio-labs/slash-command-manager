# 07-spec-list-command

## Introduction/Overview

This feature adds a `list` command to the slash-command-manager that displays all prompts currently managed by the application. The command searches through agent command directories, identifies prompts marked with `managed_by: slash-man` metadata, and presents them in a Rich-formatted tree structure similar to the `generate` command output. Each listed prompt includes information about which agents it's installed for, file paths, backup counts, consolidated source information (handling both local and GitHub sources), and last updated timestamps. The command also reports how many unmanaged prompt files exist in each agent directory (excluding backup files and non-prompt files). This provides users with visibility into their managed prompts, helps track backup versions for recovery purposes, and identifies prompts that may need to be migrated to managed status.

## Goals

- Add `managed_by: slash-man` metadata field to all command files generated by the `generate` command to enable tracking of managed prompts.
- Implement a `list` command that discovers and displays all managed prompts across configured agent locations.
- Display comprehensive information for each managed prompt including agent assignments, file paths, backup counts, consolidated source information (local or GitHub), and timestamps.
- Count and display unmanaged prompt files in each agent directory (excluding backup files and non-prompt files) to help users identify prompts that may need migration.
- Reuse existing code patterns from the `generate` command and identify opportunities to extract shared functionality into reusable utilities, following DRY principles to minimize duplication and maintain consistency.
- Provide clear messaging when no managed prompts are found, including guidance about backward compatibility with older generated files.

## User Stories

- **As a user managing multiple prompts**, I want to see all prompts currently installed by slash-command-manager so that I can understand what's deployed across my agent configurations.
- **As a developer troubleshooting prompt issues**, I want to see backup counts and last updated timestamps for each prompt so that I can identify when changes were made and how many recovery points exist.
- **As a user upgrading from older versions**, I want clear messaging about why older generated files aren't listed so that I understand the detection mechanism and can regenerate if needed.
- **As a user managing a mix of managed and unmanaged prompts**, I want to see how many unmanaged prompts exist in each agent directory so that I can identify which prompts need to be migrated to managed status.

## Demoable Units of Work

### [Unit 1]: Managed By Field Integration

**Purpose:** Automatically add `managed_by: slash-man` metadata to all command files generated by the `generate` command, enabling the list command to identify managed prompts.

**Demo Criteria:** Running `slash-man generate` creates command files with `managed_by: slash-man` in the meta section of the frontmatter. Verifying a generated file shows the field present in the YAML metadata.

**Proof Artifacts:** Unit test verifying `_build_meta` includes `managed_by` field; integration test confirming generated files contain the metadata; CLI transcript showing `cat` output of a generated file's frontmatter.

### [Unit 2]: Prompt Discovery and Filtering

**Purpose:** Implement logic to scan agent command directories, parse command files (both Markdown and TOML formats), filter for those with `managed_by: slash-man`, extract prompt metadata, and identify unmanaged prompt files.

**Demo Criteria:** Running `slash-man list` discovers all managed prompts across detected agent locations. Command files without `managed_by` field are excluded from managed results but counted as unmanaged if they are valid prompt files. Both Markdown and TOML format files are handled correctly.

**Proof Artifacts:** Unit tests for prompt discovery logic covering various scenarios (with/without managed_by field, multiple agents, empty directories, Markdown and TOML formats); integration test verifying discovery across multiple agent directories; unit tests for unmanaged prompt detection logic.

### [Unit 3]: Backup Counting

**Purpose:** Count timestamped backup files (`.bak` files matching pattern `{filename}.{timestamp}.bak`) for each managed prompt file in the same directory.

**Demo Criteria:** Running `slash-man list` shows accurate backup counts for each prompt file. Creating additional backups and re-running list shows updated counts.

**Proof Artifacts:** Unit tests for backup counting logic; integration test creating backups and verifying counts; CLI transcript showing backup counts in output.

### [Unit 4]: Rich Output Display

**Purpose:** Render managed prompts in a Rich tree format similar to `generate` command, grouped by prompt name with agent details, file paths, backup counts, consolidated source information (single line for both local and GitHub sources), timestamps, and unmanaged prompt counts per agent.

**Demo Criteria:** Running `slash-man list` displays a formatted tree structure showing all managed prompts with complete information. Source information is displayed as a single consolidated line (e.g., "local: /path/to/prompts" or "github: owner/repo@branch:path"). Unmanaged prompt counts are shown per agent directory. Output matches the style and grouping approach used by `generate` command.

**Proof Artifacts:** Integration test verifying output structure; CLI transcript or screenshot showing formatted output; unit tests for data structure building logic; test verifying source consolidation logic.

### [Unit 5]: Command Flags and Filtering

**Purpose:** Support `--target-path`, `--detection-path`, and `--agent` flags matching `generate` command behavior, allowing users to customize search scope and filter by agent.

**Demo Criteria:** Running `slash-man list --agent cursor` shows only prompts installed for Cursor. Using `--target-path` and `--detection-path` modifies search locations appropriately.

**Proof Artifacts:** Integration tests for each flag combination; CLI transcript demonstrating flag usage; unit tests for flag parsing and validation.

### [Unit 6]: Empty State and Error Handling

**Purpose:** Display helpful message when no managed prompts are found, including explanation of detection mechanism and backward compatibility notes.

**Demo Criteria:** Running `slash-man list` with no managed prompts shows informative message and exits with code 0. Message explains that only files with `managed_by` field are detected.

**Proof Artifacts:** Integration test for empty state; CLI transcript showing empty state message; unit test verifying exit code.

## Functional Requirements

1. **The system shall automatically add `managed_by: slash-man` to the meta section** of all command files generated by the `generate` command, ensuring all new and updated command files are trackable.

2. **The system shall provide a `list` command** that searches for managed prompts across agent command directories.

3. **The system shall discover managed prompts** by scanning command directories for each configured agent, parsing frontmatter (Markdown) or TOML structure, and filtering for files containing `meta.managed_by == "slash-man"`. The system shall handle both Markdown and TOML formats following the same pattern as the `generate` command.

4. **The system shall only list prompts with the `managed_by` field present**, excluding command files generated before this feature was added.

5. **The system shall count backup files** for each managed prompt by finding all files matching the pattern `{filename}.{timestamp}.bak` in the same directory as the command file.

6. **The system shall identify and count unmanaged prompt files** in each agent directory by:
   - Finding all files matching the agent's `command_file_extension`
   - Excluding backup files (matching pattern `*.{extension}.{timestamp}.bak`)
   - Excluding managed files (those with `managed_by: slash-man`)
   - Attempting to parse remaining files as prompts (valid frontmatter for Markdown, valid TOML structure for TOML)
   - Counting only files that are valid prompt files but not managed

7. **The system shall extract and display the following information for each managed prompt:**
   - Prompt name
   - Agent(s) where installed (agent key and display name)
   - File path(s) for each agent
   - Backup count per file
   - Consolidated source information (single line displaying either local path or GitHub repository information from meta.source_type, meta.source_dir, meta.source_repo, meta.source_branch, meta.source_path)
   - Last updated timestamp (from meta.updated_at)

8. **The system shall display unmanaged prompt counts** per agent directory in the output, showing how many valid prompt files exist that are not managed by slash-command-manager.

9. **The system shall group output by prompt name**, showing all agents and file paths for each prompt together in the display.

10. **The system shall support `--target-path` / `-t` flag** to specify the base directory for searching agent command directories (defaults to home directory, matching `generate` behavior).

11. **The system shall support `--detection-path` / `-d` flag** to specify the directory for agent detection (defaults to home directory, matching `generate` behavior).

12. **The system shall support `--agent` / `-a` flag** that can be specified multiple times to filter results to only the specified agents (matching `generate` command behavior).

13. **The system shall render output using Rich library** in a tree format similar to `generate` command summary, maintaining visual consistency.

14. **The system shall display an informative message when no managed prompts are found**, including:
    - Clear statement that no managed prompts were found
    - Explanation that only files with `managed_by: slash-man` metadata are detected
    - Note that files generated by older versions won't appear until regenerated
    - Exit code 0 (success, not an error condition)

15. **The system shall identify and execute on opportunities to consolidate shared functionality** between `generate` and `list` commands, extracting common logic into reusable utilities following DRY principles. This includes:
    - Agent detection and validation logic
    - Path resolution and display utilities
    - Rich rendering helpers
    - Frontmatter/TOML parsing utilities
    - Source metadata extraction and formatting
    - File discovery and filtering patterns

16. **The system shall provide comprehensive test coverage** including unit tests for discovery logic, backup counting, unmanaged prompt detection, source consolidation, and data structure building, plus integration tests demonstrating end-to-end functionality.

## Non-Goals (Out of Scope)

1. **Migration tool for adding `managed_by` to existing files**—users can regenerate prompts to add the metadata field.

2. **JSON output format**—initial implementation focuses on Rich tree format only.

3. **Filtering by prompt name or tags**—only agent filtering is supported in the initial version.

4. **Modifying or deleting prompts**—the `list` command is read-only; use `generate` or `cleanup` for modifications.

5. **Cross-directory backup aggregation**—backups are counted per file location, not aggregated across agents.

6. **Detecting prompts from GitHub sources**—the list command scans locally installed command files, but displays source information from metadata (which may indicate GitHub or local sources).

## Design Considerations

- Output format should closely match the `generate` command summary structure to maintain visual consistency and user familiarity.
- Group prompts by name (not by agent) to show all installations of each prompt together, making it easier to see where a prompt is deployed.
- Use Rich Tree structure similar to `generate` command with sections for prompts, agents, files, and backup counts.
- Empty state message should be informative but not alarming, since having no managed prompts is a valid state (especially for new users or after cleanup).
- Identify and extract shared functionality between `generate` and `list` commands into reusable utility modules, following DRY principles. This includes consolidating agent detection, path resolution, Rich rendering, frontmatter/TOML parsing, and source metadata handling into shared utilities.
- Reuse existing helper functions from `cli.py` and `writer.py` where possible, and refactor to extract common patterns into shared modules to reduce code duplication and maintain consistency.

## Repository Standards

- Follow established Python style enforced by `ruff format` and `ruff check`.
- Place tests under `tests/` with unit tests for discovery and counting logic, integration tests under `tests/integration/` mirroring existing structure.
- Update documentation/spec artifacts inside `docs/specs/07-spec-list-command/` and provide proofs similar to prior specs.
- Use conventional commits and ensure `pre-commit run --all-files` succeeds before submission.
- **Execute implementation with strict TDD workflow**: write failing tests first, implement only enough code to make them pass, iterate until all acceptance criteria are covered, and refactor while keeping tests green.

## Technical Considerations

- **Prompt Discovery**: Reuse `detect_agents()` from `detection.py` and agent configuration from `config.py`. Scan each agent's `command_dir` for command files matching the agent's `command_file_extension`.

- **Frontmatter/TOML Parsing**: Reuse `parse_frontmatter()` from `mcp_server/prompt_utils.py` for Markdown files. For TOML files, use `tomli` or similar library following the pattern used in `generate` command. Extract parsing logic into a shared utility module to handle both formats consistently.

- **Backup Pattern Matching**: Use `Path.glob()` with pattern `{filename}.*.bak` to find backup files. Parse timestamps from filenames if needed for sorting, but counting is sufficient for initial implementation. Reuse backup detection pattern from `writer.py` if available.

- **Unmanaged Prompt Detection**: For each agent directory, scan files matching the agent's `command_file_extension`, exclude backup files (using backup pattern), exclude managed files (checking for `managed_by` field), and attempt to parse remaining files. Valid prompts have parseable frontmatter (Markdown) or valid TOML structure. Count only valid prompt files that aren't managed.

- **Rich Rendering**: Extract shared Rich rendering patterns from `_render_rich_summary()` in `cli.py` into a utility module. Both `generate` and `list` commands should use the same rendering utilities to maintain visual consistency and reduce duplication.

- **Path Resolution**: Extract `_relative_to_candidates()` or similar path display logic from `cli.py` into a shared utility module. Both commands should use the same path resolution logic.

- **Agent Filtering**: Extract agent validation and filtering logic from `generate` command into a shared utility module. Both commands should use the same agent filtering logic to ensure consistent behavior.

- **Source Metadata Extraction and Consolidation**: Extract source metadata from command file frontmatter/TOML meta section. Consolidate source information into a single display line:
  - For local sources: Display `meta.source_dir` if present, or fallback to `meta.source_path`
  - For GitHub sources: Display format `meta.source_repo@meta.source_branch:meta.source_path`
  - Handle missing fields gracefully (show "Unknown" or omit if not present)
  - Extract this logic into a shared utility function for consistent formatting

- **Code Consolidation**: Actively identify and extract shared logic between `generate` and `list` commands into reusable utility modules. Priority areas for consolidation:
  - Agent detection and validation (`detection.py` may already provide some of this)
  - Path resolution and display utilities
  - Rich rendering helpers (extract into `cli_utils.py` or similar)
  - Frontmatter/TOML parsing utilities (may extend `mcp_server/prompt_utils.py`)
  - Source metadata extraction and formatting
  - File discovery and filtering patterns

## Success Metrics

1. **Test Coverage**: Achieve >90% code coverage for new list command functionality including discovery, filtering, and backup counting logic.

2. **Code Consolidation**: Extract at least 3 shared utilities from common patterns between `generate` and `list` commands (e.g., agent detection/validation, path resolution, Rich rendering, source metadata formatting). Both commands should use these shared utilities, demonstrating DRY principles.

3. **Performance**: List command completes in <2 seconds for typical installations with <50 managed prompts across multiple agents.

4. **User Feedback**: Output format matches `generate` command style closely enough that users familiar with `generate` can immediately understand `list` output.

5. **Documentation**: All proof artifacts (tests, CLI transcripts, screenshots) are captured and demonstrate end-to-end functionality.

## Open Questions

1. Should the list command show disabled prompts (where `enabled: false` in frontmatter)? **Assumption: Yes, show all managed prompts regardless of enabled status, but could mark disabled ones visually.**

2. How should we handle command files with malformed frontmatter? **Assumption: Skip them silently and continue scanning, but log a warning in debug mode. These files are not counted as unmanaged prompts since they cannot be validated as valid prompt files.**

3. Should backup counts be shown per-file or aggregated per-prompt across all agents? **Assumption: Per-file as specified in requirements, showing backup count for each file path.**

4. Do we need to handle TOML format command files differently than Markdown? **Assumption: Handle both formats following the same pattern as `generate` command. Use appropriate parsing libraries (YAML for Markdown frontmatter, TOML library for TOML files) and extract parsing logic into shared utilities.**

No open questions at this time—assumptions documented above can be validated during implementation.
